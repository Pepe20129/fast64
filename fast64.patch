diff --git a/fast64_internal/oot/collision/exporter/to_c/collision.py b/fast64_internal/oot/collision/exporter/to_c/collision.py
index 3a08aa9..f1c894e 100644
--- a/fast64_internal/oot/collision/exporter/to_c/collision.py
+++ b/fast64_internal/oot/collision/exporter/to_c/collision.py
@@ -31,7 +31,7 @@ def ootCollisionVertexToC(vertex):
 
 
 def ootCollisionVertexToXML(vertex):
-    return f'    <Vertex X="{str(vertex.position[0])}" Y="{str(vertex.position[1])}" Z="{str(vertex.position[2])}"/>\n'
+    return indent + f'<Vertex X="{str(vertex.position[0])}" Y="{str(vertex.position[1])}" Z="{str(vertex.position[2])}"/>\n'
 
 
 def ootCollisionPolygonToC(polygon, ignoreCamera, ignoreActor, ignoreProjectile, enableConveyor, polygonTypeIndex):
@@ -55,7 +55,8 @@ def ootCollisionPolygonToC(polygon, ignoreCamera, ignoreActor, ignoreProjectile,
 
 def ootCollisionPolygonToXML(polygon, ignoreCamera, ignoreActor, ignoreProjectile, enableConveyor, polygonTypeIndex):
     return (
-        f'    <Polygon Type="{str(polygonTypeIndex)}" ' +
+        indent +
+        f'<Polygon Type="{str(polygonTypeIndex)}" ' +
         f'VertexA="{str(polygon.convertShort02(ignoreCamera, ignoreActor, ignoreProjectile))}" ' +
         f'VertexB="{str(polygon.convertShort04(enableConveyor))}" ' +
         f'VertexC="{str(polygon.convertShort06())}" ' +
@@ -74,7 +75,7 @@ def ootPolygonTypeToC(polygonType):
 
 def ootPolygonTypeToXML(polygonType):
     # might be reversed
-    return f'    <PolygonType Data1="{polygonType.convertHigh()}" Data2="{polygonType.convertLow()}"/>\n'
+    return indent + f'<PolygonType Data1="{polygonType.convertHigh()}" Data2="{polygonType.convertLow()}"/>\n'
 
 
 def ootWaterBoxToC(waterBox):
@@ -97,7 +98,8 @@ def ootWaterBoxToC(waterBox):
 
 def ootWaterBoxToXML(waterBox):
     return (
-        f'    <WaterBox XMin="{str(waterBox.low[0])}" ' +
+        indent +
+        f'<WaterBox XMin="{str(waterBox.low[0])}" ' +
         f'Ysurface="{str(waterBox.height)}" ' +
         f'ZMin="{str(waterBox.low[1])}" ' +
         f'XLength="{str(waterBox.high[0] - waterBox.low[0])}" ' +
@@ -158,9 +160,9 @@ def ootCameraDataToXML(camData):
                     camPosIndex += 3
                     exportPosData = True
             elif isinstance(camItem, OOTCrawlspaceData):
-                # camXML += ootCrawlspaceEntryToXML(camItem, camData, camPosIndex)
-                # posXML += ootCrawlspaceToXML(camItem)
-                # camPosIndex += len(camItem.points) * 3
+                camXML += ootCrawlspaceEntryToXML(camItem, camData, camPosIndex)
+                posXML += ootCrawlspaceToXML(camItem)
+                camPosIndex += len(camItem.points) * 3
                 raise PluginError(f"TODO: OOTCrawlspaceData")
             else:
                 raise PluginError(f"Invalid object type in camera position dict: {type(camItem)}")
@@ -195,16 +197,13 @@ def ootCameraPosToC(camPos):
 
 
 def ootCameraPosToXML(camPos):
-    return '    <CameraPositionData PosX="{PosX}" PosY="{PosY}" PosZ="{PosZ}" RotX="{RotX}" RotY="{RotY}" RotZ="{RotZ}" FOV="{FOV}" JfifID="{JfifID}" Unknown="{Unknown}"/>\n'.format(
-        PosX=str(camPos.position[0]),
-        PosY=str(camPos.position[1]),
-        PosZ=str(camPos.position[2]),
-        RotX=str(camPos.rotation[0]),
-        RotY=str(camPos.rotation[1]),
-        RotZ=str(camPos.rotation[2]),
-        FOV=str(camPos.fov),
-        JfifID=str(camPos.bgImageOverrideIndex),
-        Unknown=str(camPos.unknown),
+    return (
+        indent +
+        f'<CameraPositionData PosX="{str(camPos.position[0])}" PosY="{str(camPos.position[1])}" PosZ="{str(camPos.position[2])}"' +
+        f'RotX="{str(camPos.rotation[0])}" RotY="{str(camPos.rotation[1])}" RotZ="{str(camPos.rotation[2])}"' +
+        f'FOV="{str(camPos.fov)}"' +
+        f'JfifID="{str(camPos.bgImageOverrideIndex)}"' +
+        f'Unknown="{str(camPos.unknown)}"/>\n'
     )
 
 
@@ -221,10 +220,11 @@ def ootCameraEntryToC(camPos, camData, camPosIndex):
 
 
 def ootCameraEntryToXML(camPos, camData, camPosIndex):
-    return '    <CameraData SType="{SType}" NumData="{NumData}" CameraPosDataSeg="{CameraPosDataSeg}"/>'.format(
-        SType=str(int(camPos.camSType, 16)),
-        NumData=("3" if camPos.hasPositionData else "0"),
-        CameraPosDataSeg=(camPosIndex if camPos.hasPositionData else "0"),
+    return (
+        indent +
+        f'<CameraData SType="{str(int(camPos.camSType, 16))}"' +
+        f'NumData="{("3" if camPos.hasPositionData else "0")}"' +
+        f'CameraPosDataSeg="{(camPosIndex if camPos.hasPositionData else "0")}"/>'
     )
 
 
@@ -236,6 +236,16 @@ def ootCrawlspaceToC(camItem: OOTCrawlspaceData):
     return data
 
 
+def ootCrawlspaceToXML(camItem: OOTCrawlspaceData):
+    data = "<!-- TODO\n"
+    for point in camItem.points:
+        data += f"\t{{{point[0]}, {point[1]}, {point[2]}}},\n" * 3
+
+    data += "\n-->"
+
+    return data
+
+
 def ootCrawlspaceEntryToC(camItem: OOTCrawlspaceData, camData: OOTCameraData, camPosIndex: int):
     return " ".join(
         (
@@ -248,6 +258,18 @@ def ootCrawlspaceEntryToC(camItem: OOTCrawlspaceData, camData: OOTCameraData, ca
     )
 
 
+def ootCrawlspaceEntryToXML(camItem: OOTCrawlspaceData, camData: OOTCameraData, camPosIndex: int):
+    return "<!-- TODO\n" + " ".join(
+        (
+            "{",
+            camItem.camSType + ",",
+            str((len(camItem.points) * 3)) + ",",
+            (("&" + camData.camPositionsName() + "[" + str(camPosIndex) + "]") if len(camItem.points) > 0 else "NULL"),
+            "}",
+        )
+    ) + "\n-->"
+
+
 def ootCollisionToC(collision):
     data = CData()
     posC, camC = ootCameraDataToC(collision.cameraData)
@@ -352,19 +374,20 @@ def ootCollisionToC(collision):
 def ootCollisionToXML(collision):
     data = "<CollisionHeader "
     if len(collision.bounds) == 2:
-        data += 'MinBoundsX="{MinBoundsX}" MinBoundsY="{MinBoundsY}" MinBoundsZ="{MinBoundsZ}" '.format(
-            MinBoundsX=str(collision.bounds[0][0]),
-            MinBoundsY=str(collision.bounds[0][1]),
-            MinBoundsZ=str(collision.bounds[0][2]),
-        )
-        data += 'MaxBoundsX="{MaxBoundsX}" MaxBoundsY="{MaxBoundsY}" MaxBoundsZ="{MaxBoundsZ}"'.format(
-            MaxBoundsX=str(collision.bounds[1][0]),
-            MaxBoundsY=str(collision.bounds[1][1]),
-            MaxBoundsZ=str(collision.bounds[1][2]),
+        data += (
+            f'MinBoundsX="{str(collision.bounds[0][0])}" ' +
+            f'MinBoundsY="{str(collision.bounds[0][1])}" ' +
+            f'MinBoundsZ="{str(collision.bounds[0][2])}" ' +
+
+            f'MaxBoundsX="{str(collision.bounds[1][0])}" ' +
+            f'MaxBoundsY="{str(collision.bounds[1][1])}" ' +
+            f'MaxBoundsZ="{str(collision.bounds[1][2])}"'
         )
     else:
-        data += 'MinBoundsX="0" MinBoundsY="0" MinBoundsZ="0" '
-        data += 'MaxBoundsX="0" MaxBoundsY="0" MaxBoundsZ="0"'
+        data += (
+            'MinBoundsX="0" MinBoundsY="0" MinBoundsZ="0" ' +
+            'MaxBoundsX="0" MaxBoundsY="0" MaxBoundsZ="0"'
+        )
 
     data += ">\n"
 
@@ -457,28 +480,47 @@ def exportCollisionToC(
         ootCleanupScene(originalObj, allObjs)
 
 
-def exportCollisionToXML(originalObj, transformMatrix, includeChildren, name, isCustomExport, folderName, exportPath):
+def exportCollisionToXML(
+    originalObj: bpy.types.Object,
+    transformMatrix: mathutils.Matrix,
+    exportSettings: OOTCollisionExportSettings
+):
+    name = toAlnum(originalObj.name)
+    isCustomExport = exportSettings.customExport
+    folderName = exportSettings.folder
+    exportPath = ootGetObjectPath(isCustomExport, bpy.path.abspath(exportSettings.exportPath), folderName, False)
+
     collision = OOTCollision(name)
     collision.cameraData = OOTCameraData(name)
 
     if bpy.context.scene.exportHiddenGeometry:
-        hiddenObjs = unhideAllAndGetHiddenList(bpy.context.scene)
+        hiddenState = unhideAllAndGetHiddenState(bpy.context.scene)
 
     # Don't remove ignore_render, as we want to resuse this for collision
     obj, allObjs = ootDuplicateHierarchy(originalObj, None, True, OOTObjectCategorizer())
 
     if bpy.context.scene.exportHiddenGeometry:
-        hideObjsInList(hiddenObjs)
+        restoreHiddenState(hiddenState)
 
     try:
-        exportCollisionCommon(collision, obj, transformMatrix, includeChildren, name)
-        ootCleanupScene(originalObj, allObjs)
+        if not obj.ignore_collision:
+            colData = (
+                CollisionHeader.new(
+                    f"{name}_collisionHeader",
+                    name,
+                    obj,
+                    transformMatrix,
+                    bpy.context.scene.fast64.oot.useDecompFeatures,
+                    exportSettings.includeChildren,
+                ).getXML()
+            )
+
+            path = ootGetPath(exportPath, isCustomExport, "assets/objects/", folderName, False, False)
+            filename = exportSettings.filename if exportSettings.isCustomFilename else f"{name}_collision"
+            writeXMLData(colData, os.path.join(path, filename))
+        else:
+            raise PluginError("ERROR: The selected mesh object ignores collision!")
     except Exception as e:
-        ootCleanupScene(originalObj, allObjs)
         raise Exception(str(e))
-
-    collisionXML = ootCollisionToXML(collision)
-
-    path = ootGetPath(exportPath, isCustomExport, "assets/objects/", folderName, False, False)
-    filename = exportSettings.filename if exportSettings.isCustomFilename else f"{name}_collision"
-    writeXMLData(collisionXML, os.path.join(path, filename))
\ No newline at end of file
+    finally:
+        ootCleanupScene(originalObj, allObjs)
diff --git a/fast64_internal/oot/collision/operators.py b/fast64_internal/oot/collision/operators.py
index 38fe2a5..9001921 100644
--- a/fast64_internal/oot/collision/operators.py
+++ b/fast64_internal/oot/collision/operators.py
@@ -28,7 +28,10 @@ class OOT_ExportCollision(Operator):
 
         try:
             exportSettings: OOTCollisionExportSettings = context.scene.fast64.oot.collisionExportSettings
-            exportCollisionToC(obj, finalTransform, exportSettings)
+            if context.scene.fast64.oot.featureSet == "SoH":
+                exportCollisionToXML(obj, finalTransform, exportSettings)
+            else:
+                exportCollisionToC(obj, finalTransform, exportSettings)
 
             self.report({"INFO"}, "Success!")
             return {"FINISHED"}
diff --git a/fast64_internal/oot/exporter/__init__.py b/fast64_internal/oot/exporter/__init__.py
index e85ef12..1d523ca 100644
--- a/fast64_internal/oot/exporter/__init__.py
+++ b/fast64_internal/oot/exporter/__init__.py
@@ -135,3 +135,134 @@ class SceneExport:
                 f"ENTR_{sceneName.upper()}_{hackerootBootOption.spawnIndex}",
                 hackerootBootOption,
             )
+
+    def export_xml(originalSceneObj: Object, transform: Matrix, exportInfo: ExportInfo, logging_func):
+        checkObjectReference(originalSceneObj, "Scene object")
+        scene = SceneExport.create_scene(originalSceneObj, transform, exportInfo)
+
+        exportSubdir = ""
+        if exportInfo.customSubPath is not None:
+            exportSubdir = exportInfo.customSubPath
+
+        logging_func({"INFO"}, "ootExportSceneToXML 3")
+
+        resourceBasePath = ""
+
+        if bpy.context.scene.ootSceneExportSettings.option == "Custom":
+            resourceBasePath = bpy.context.scene.ootSceneExportSettings.sohCustomResourcePath
+        elif bpy.context.scene.ootSceneExportSettings.sohResourcePath == "Shared":
+            resourceBasePath = f"scenes/shared/{scene.name}/"
+        elif bpy.context.scene.ootSceneExportSettings.sohResourcePath == "Vanilla":
+            resourceBasePath = f"scenes/nonmq/{scene.name}/"
+        elif bpy.context.scene.ootSceneExportSettings.sohResourcePath == "MQ":
+            resourceBasePath = f"scenes/mq/{scene.name}/"
+        else:
+            logging_func({"ERROR"}, f"Unknown sohResourcePath")
+            return
+
+        logging_func(
+            {"INFO"},
+            "ootExportSceneToXML 4.1 resourceBasePath=" + (resourceBasePath if resourceBasePath is not None else "None"),
+        )
+        logging_func(
+            {"INFO"}, "ootExportSceneToXML 4.2 exportSubdir=" + (exportSubdir if exportSubdir is not None else "None")
+        )
+        logging_func({"INFO"}, "ootExportSceneToXML 4.3 scene.name=" + (scene.name if scene.name is not None else "None"))
+        logging_func(
+            {"INFO"},
+            "ootExportSceneToXML 4.4 exportInfo.exportPath="
+            + (exportInfo.exportPath if exportInfo.exportPath is not None else "None"),
+        )
+        sceneInclude = exportSubdir + "/" + scene.name + "/"
+        exportPath = exportInfo.exportPath
+        for section in resourceBasePath.split("/"):
+            exportPath = os.path.join(exportPath, section)
+        path = ootGetPath(exportPath, True, exportSubdir, scene.name, True, True)
+
+        levelXML = getSceneXML(
+            scene, TextureExportSettings(False, savePNG, sceneInclude, path), resourceBasePath, logging_func
+        )
+        logging_func({"INFO"}, "ootExportSceneToXML 5")
+
+        textureArrayData = writeTextureArraysNewXML(scene.model, None)
+        logging_func(
+            {"INFO"},
+            "ootExportSceneToXML 6 levelXML.sceneTexturesXML="
+            + (levelXML.sceneTexturesXML if levelXML.sceneTexturesXML is not None else "None"),
+        )
+        logging_func(
+            {"INFO"},
+            "ootExportSceneToXML 7 textureArrayData=" + (textureArrayData if textureArrayData is not None else "None"),
+        )
+        # levelXML.sceneTexturesXML.append(textureArrayData)
+        logging_func({"INFO"}, "ootExportSceneToXML 8")
+
+        logging_func({"INFO"}, f"ootExportSceneToXML 9 path={(path if path is not None else 'None')}")
+        # TODO: uses Room instead of Scene due to a SoH limitation
+        writeXMLData(
+            '{\n    "path": "'
+            + resourceBasePath
+            + scene.name
+            + '.xml",\n    "type": "Room",\n    "format": "XML",\n    "version": 0\n}',
+            os.path.join(path, scene.name + ".meta"),
+        )
+        writeXMLData(
+            ootCombineSceneFilesXML(levelXML).replace("{resource_base_path}", resourceBasePath[:-1]),
+            os.path.join(path, scene.name + ".xml"),
+        )
+        for i in range(len(levelXML.sceneAlternateHeadersXML)):
+            writeXMLData(
+                levelXML.sceneAlternateHeadersXML[i].replace("{resource_base_path}", resourceBasePath[:-1]),
+                os.path.join(path, scene.name + "_alternate_headers_" + str(i) + ".xml"),
+            )
+        for i in range(len(levelXML.scenePathDataXML)):
+            writeXMLData(
+                levelXML.scenePathDataXML[i].replace("{resource_base_path}", resourceBasePath[:-1]),
+                os.path.join(path, scene.name + "_pathway_" + str(i) + ".xml"),
+            )
+        writeXMLData(
+            levelXML.sceneCollisionXML.replace("{resource_base_path}", resourceBasePath[:-1]),
+            os.path.join(path, scene.name + "_collision.xml"),
+        )
+        logging_func({"INFO"}, "ootExportSceneToXML 10")
+        for i in range(len(scene.rooms.entries)):
+            logging_func({"INFO"}, "ootExportSceneToXML 11")
+            roomXML = levelXML.roomMainXML[scene.rooms.entries[i].roomName()]
+            writeXMLData(
+                roomXML.replace("{resource_base_path}", resourceBasePath[:-1]),
+                os.path.join(path, scene.rooms.entries[i].roomName() + ".xml"),
+            )
+
+            for j in range(len(levelXML.roomAlternateHeadersXML[scene.rooms.entries[i].roomName()])):
+                writeXMLData(
+                    levelXML.roomAlternateHeadersXML[scene.rooms.entries[i].roomName()][j].replace(
+                        "{resource_base_path}", resourceBasePath[:-1]
+                    ),
+                    os.path.join(path, scene.rooms.entries[i].roomName() + "_alternate_headers_" + str(j) + ".xml"),
+                )
+
+            for meshEntry in scene.rooms.entries[i].mesh.meshEntries:
+                opaqueName = meshEntry.DLGroup.opaque.name if meshEntry.DLGroup.opaque is not None else ""
+                transparentName = meshEntry.DLGroup.transparent.name if meshEntry.DLGroup.transparent is not None else ""
+                if meshEntry.DLGroup.opaque is not None:
+                    writeXMLData(
+                        meshEntry.DLGroup.opaque.to_soh_xml(None, "{resource_base_path}").replace(
+                            "{resource_base_path}", resourceBasePath[:-1]
+                        ),
+                        os.path.join(path, opaqueName + ".xml"),
+                    )
+                if meshEntry.DLGroup.transparent is not None:
+                    writeXMLData(
+                        meshEntry.DLGroup.transparent.to_soh_xml(None, "{resource_base_path}").replace(
+                            "{resource_base_path}", resourceBasePath[:-1]
+                        ),
+                        os.path.join(path, transparentName + ".xml"),
+                    )
+
+            logging_func({"INFO"}, "ootExportSceneToXML 12")
+
+        # Copy bg images
+        for room in scene.rooms.entries:
+            room.roomShape.copy_bg_images(path)
+
+        logging_func({"INFO"}, "ootExportSceneToXML 13")
\ No newline at end of file
diff --git a/fast64_internal/oot/exporter/actor.py b/fast64_internal/oot/exporter/actor.py
index ad1d78c..f535c98 100644
--- a/fast64_internal/oot/exporter/actor.py
+++ b/fast64_internal/oot/exporter/actor.py
@@ -31,9 +31,9 @@ class Actor:
             + ("\n" + indent + "},\n")
         )
 
-    def getActorEntryXML(actor: OOTActor):
+    def getActorEntryXML(self):
         """Returns a single actor entry"""
-        split_rotation = actor.rotation.split(", ")
+        split_rotation = self.rot.split(", ")
         split_processed_rotation = []
         for split_rotation_value in split_rotation:
             split_processed_rotation.append(
@@ -42,13 +42,13 @@ class Actor:
                 else int(float(re.search(r"DEG_TO_BINANG\(([^()]*?)\)", split_rotation_value).group(1)) * 0x8000 / 180)
             )
 
-        actorID = actor.actorID
+        actorID = self.actorID
         for i, actorElement in enumerate(ootActorIds):
             if actorElement == actorID:
                 actorID = i
 
         return (
             indent * 2
-            + f'<ActorEntry Id="{actorID}" PosX="{actor.position[0]}" PosY="{actor.position[1]}" PosZ="{actor.position[2]}" '
-            + f'RotX="{split_processed_rotation[0]}" RotY="{split_processed_rotation[1]}" RotZ="{split_processed_rotation[2]}" Params="{int(actor.actorParam, 16)}"/>'
+            + f'<ActorEntry Id="{actorID}" PosX="{self.pos[0]}" PosY="{self.pos[1]}" PosZ="{self.pos[2]}" '
+            + f'RotX="{split_processed_rotation[0]}" RotY="{split_processed_rotation[1]}" RotZ="{split_processed_rotation[2]}" Params="{int(self.params, 16)}"/>'
         )
diff --git a/fast64_internal/oot/exporter/collision/__init__.py b/fast64_internal/oot/exporter/collision/__init__.py
index da2cf95..d88b974 100644
--- a/fast64_internal/oot/exporter/collision/__init__.py
+++ b/fast64_internal/oot/exporter/collision/__init__.py
@@ -312,37 +312,35 @@ class CollisionHeader:
         headerData.append(colData)
         return headerData
 
+
     def getXML(collision):
-        data = "<CollisionHeader "
-        if len(collision.bounds) == 2:
-            data += f'MinBoundsX="{str(collision.bounds[0][0])}" ' +
-                    f'MinBoundsY="{str(collision.bounds[0][1])}" ' +
-                    f'MinBoundsZ="{str(collision.bounds[0][2])}" ' +
-                    f'MaxBoundsX="{str(collision.bounds[1][0])}" ' +
-                    f'MaxBoundsY="{str(collision.bounds[1][1])}" ' +
-                    f'MaxBoundsZ="{str(collision.bounds[1][2])}"'
-        else:
-            data += 'MinBoundsX="0" MinBoundsY="0" MinBoundsZ="0" MaxBoundsX="0" MaxBoundsY="0" MaxBoundsZ="0"'
-
-        data += ">\n"
+        data = (
+            "<CollisionHeader " +
+            f'MinBoundsX="{str(self.minBounds[0])}" ' +
+            f'MinBoundsY="{str(self.minBounds[1])}" ' +
+            f'MinBoundsZ="{str(self.minBounds[2])}" ' +
+            f'MaxBoundsX="{str(self.maxBounds[0])}" ' +
+            f'MaxBoundsY="{str(self.maxBounds[1])}" ' +
+            f'MaxBoundsZ="{str(self.maxBounds[2])}"' +
+            ">\n"
+        )
 
         # Add vertex data
         if len(self.vertices.vertexList) > 0:
-            colData.append(self.vertices.getXML())
+            data += self.vertices.getXML()
 
         # Add surface types
         if len(self.surfaceType.surfaceTypeList) > 0:
-            colData.append(self.surfaceType.getXML())
+            data += self.surfaceType.getXML()
 
         # Add collision poly data
         if len(self.collisionPoly.polyList) > 0:
-            colData.append(self.collisionPoly.getXML())
+            data += self.collisionPoly.getXML()
 
         # Add camera data if necessary
         if len(self.bgCamInfo.bgCamInfoList) > 0 or len(self.bgCamInfo.crawlspacePosList) > 0:
-            infoData = self.bgCamInfo.getInfoArrayXML()
             data += self.bgCamInfo.getDataArrayXML()
-            data += infoData
+            data += self.bgCamInfo.getInfoArrayXML()
 
         # Add waterbox data if necessary
         if len(self.waterbox.waterboxList) > 0:
diff --git a/fast64_internal/oot/exporter/collision/camera.py b/fast64_internal/oot/exporter/collision/camera.py
index 691ab32..33de135 100644
--- a/fast64_internal/oot/exporter/collision/camera.py
+++ b/fast64_internal/oot/exporter/collision/camera.py
@@ -24,11 +24,31 @@ class CrawlspaceCamera:
 
         return "".join(indent + "{ " + f"{point[0]:6}, {point[1]:6}, {point[2]:6}" + " },\n" for point in self.points)
 
-    def getDataEntryXML(self, posDataName: str):
+    def getDataEntryXML(self):
+        """Returns an entry for the camera data array"""
+
+        return (
+            indent +
+            (f'<!-- TODO CrawlspaceCamera getDataEntryXML point[0]={point[0]} point[1]={point[1]} point[2]={point[2]} -->\n' for point in self.points)
+        )
+
+    def getInfoEntryC(self, posDataName: str):
         """Returns a crawlspace entry for the camera informations array"""
 
         return indent + "{ " + f"CAM_SET_CRAWLSPACE, 6, &{posDataName}[{self.arrayIndex}]" + " },\n"
 
+    def getInfoEntryXML(self, posDataName: str):
+        """Returns a crawlspace entry for the camera informations array"""
+
+        #CAM_SET_CRAWLSPACE is 30 (0x1E)
+        return (
+            indent +
+            f'<CameraData SType="{30}" ' +
+            f'NumData="6" ' +
+            f'CameraPosDataSeg="{self.arrayIndex if self.hasPosData else "0"}"/>' +
+            f'<!-- posDataName={posDataName} self.count={self.count} self.arrayIndex={self.arrayIndex} -->'
+        )
+
 
 @dataclass
 class CameraData:
diff --git a/fast64_internal/oot/exporter/collision/surface.py b/fast64_internal/oot/exporter/collision/surface.py
index cd2c5d2..f8062ee 100644
--- a/fast64_internal/oot/exporter/collision/surface.py
+++ b/fast64_internal/oot/exporter/collision/surface.py
@@ -107,23 +107,27 @@ class SurfaceType:
             return (indent + "{\n") + self.getSurfaceType0() + ",\n" + self.getSurfaceType1() + ("\n" + indent + "},")
 
     def getEntryXML(self):
-        surfaceType0 = ((int(self.getIsHorseBlockedC()) & 1) << 31) |
-                       ((int(self.getIsSoftC()) & 1) << 30) |
-                       ((int(self.floorProperty) & 0x0F) << 26) |
-                       ((int(self.wallType) & 0x1F) << 21) |
-                       ((int(self.unk18) & 0x07) << 18) |
-                       ((int(self.floorType) & 0x1F) << 13) |
-                       ((int(self.exitIndex) & 0x1F) << 8) |
-                       (int(self.bgCamIndex) & 0xFF)
-
-        surfaceType1 =  ((int(self.getIsWallDamageC()) & 1) << 27) |
-                        ((int(self.conveyorDirection) & 0x3F) << 21) |
-                        ((int(self.conveyorSpeed) & 0x07) << 18) |
-                        ((int(self.getCanHookshotC()) & 1) << 17) |
-                        ((int(self.echo) & 0x3F) << 11) |
-                        ((int(self.lightSetting) & 0x1F) << 6) |
-                        ((int(self.floorEffect) & 0x03) << 4) |
-                        (int(self.material) & 0x0F)
+        surfaceType0 = (
+            ((int(self.getIsHorseBlockedC()) & 1) << 31) |
+            ((int(self.getIsSoftC()) & 1) << 30) |
+            ((int(self.floorProperty) & 0x0F) << 26) |
+            ((int(self.wallType) & 0x1F) << 21) |
+            ((int(self.unk18) & 0x07) << 18) |
+            ((int(self.floorType) & 0x1F) << 13) |
+            ((int(self.exitIndex) & 0x1F) << 8) |
+            (int(self.bgCamIndex) & 0xFF)
+        )
+
+        surfaceType1 = (
+            ((int(self.getIsWallDamageC()) & 1) << 27) |
+            ((int(self.conveyorDirection) & 0x3F) << 21) |
+            ((int(self.conveyorSpeed) & 0x07) << 18) |
+            ((int(self.getCanHookshotC()) & 1) << 17) |
+            ((int(self.echo) & 0x3F) << 11) |
+            ((int(self.lightSetting) & 0x1F) << 6) |
+            ((int(self.floorEffect) & 0x03) << 4) |
+            (int(self.material) & 0x0F)
+        )
 
         return (
             indent +
diff --git a/fast64_internal/oot/exporter/collision/waterbox.py b/fast64_internal/oot/exporter/collision/waterbox.py
index 7323655..b1f24c3 100644
--- a/fast64_internal/oot/exporter/collision/waterbox.py
+++ b/fast64_internal/oot/exporter/collision/waterbox.py
@@ -86,10 +86,12 @@ class WaterBox:
         )
 
     def getEntryXML(self):
-        properties = ((int(self.setFlag19C) & 1) << 19) |
-                     ((int(self.roomIndexC) & 0x3F) << 13) |
-                     ((int(self.lightIndex) & 0x1F) <<  8) |
-                     (int(self.bgCamIndex) & 0xFF)
+        properties = (
+            ((int(self.setFlag19C) & 1) << 19) |
+            ((int(self.roomIndexC) & 0x3F) << 13) |
+            ((int(self.lightIndex) & 0x1F) <<  8) |
+            (int(self.bgCamIndex) & 0xFF)
+        )
 
         return (
             indent +
diff --git a/fast64_internal/oot/exporter/room/__init__.py b/fast64_internal/oot/exporter/room/__init__.py
index e1ae05d..91984de 100644
--- a/fast64_internal/oot/exporter/room/__init__.py
+++ b/fast64_internal/oot/exporter/room/__init__.py
@@ -139,26 +139,17 @@ class Room:
     def getCmdListXML(self, curHeader: RoomHeader, hasAltHeaders: bool):
         """Returns the room commands list"""
 
-        cmdListData = CData()
-        listName = f"SceneCmd {curHeader.name}"
-
-        # .h
-        cmdListData.header = f"extern {listName}[];\n"
-
-        # .c
-        cmdListData.source = (
-            (f"{listName}[]" + " = {\n")
-            + (Utility.getAltHeaderListCmd(self.altHeader.name) if hasAltHeaders else "")
-            + self.roomShape.get_cmds_xml()
-            + curHeader.infos.getCmdsXML()
-            + (curHeader.objects.getCmdXML() if len(curHeader.objects.objectList) > 0 else "")
-            + (curHeader.actors.getCmdXML() if len(curHeader.actors.actorList) > 0 else "")
-            + Utility.getEndCmd()
-            + "};\n\n"
+        return (
+            "<!--" +
+            f"hasAltHeaders={hasAltHeaders} Utility.getAltHeaderListCmd(self.altHeader.name)={(Utility.getAltHeaderListCmd(self.altHeader.name) if hasAltHeaders else '')}" +
+            "-->" +
+            self.roomShape.get_cmds_xml() +
+            curHeader.infos.getCmdsXML() +
+            (curHeader.objects.getCmdXML() if len(curHeader.objects.objectList) > 0 else "") +
+            (curHeader.actors.getCmdXML() if len(curHeader.actors.actorList) > 0 else "") +
+            Utility.getEndCmdXML()
         )
 
-        return cmdListData
-
     def getRoomMainC(self):
         """Returns the C data of the main informations of a room"""
 
@@ -210,6 +201,57 @@ class Room:
 
         return roomC
 
+    def getRoomMainXML(self):
+        """Returns the XML data of the main informations of a room"""
+
+        roomHeaders: list[tuple[RoomHeader, str]] = []
+        altHeaderPtrList = None
+
+        if self.hasAlternateHeaders:
+            roomHeaders: list[tuple[RoomHeader, str]] = [
+                (self.altHeader.childNight, "Child Night"),
+                (self.altHeader.adultDay, "Adult Day"),
+                (self.altHeader.adultNight, "Adult Night"),
+            ]
+
+            for i, csHeader in enumerate(self.altHeader.cutscenes):
+                roomHeaders.append((csHeader, f"Cutscene No. {i + 1}"))
+
+            altHeaderPtrList = (
+                "<!-- altHeaderPtrList start -->" +
+                "\n".join(
+                    (
+                        indent +
+                        "<!-- " +
+                        (f"{curHeader.name} \"{headerDesc}\"" if curHeader is not None else "NULL") +
+                        " -->"
+                    )
+                    for (curHeader, headerDesc) in roomHeaders
+                ) +
+                "<!-- altHeaderPtrList end -->"
+            )
+
+        roomHeaders.insert(0, (self.mainHeader, "Child Day (Default)"))
+        roomXML = ""
+        for i, (curHeader, headerDesc) in enumerate(roomHeaders):
+            if curHeader is not None:
+                roomXML += f"<!-- Header {i}: \"{headerDesc}\" start -->\n"
+
+                roomXML += self.getCmdListXML(curHeader, i == 0 and self.hasAlternateHeaders)
+
+                if i == 0 and self.hasAlternateHeaders and altHeaderPtrList is not None:
+                    roomXML += altHeaderPtrList
+
+                if len(curHeader.objects.objectList) > 0:
+                    roomXML += curHeader.objects.getXML()
+
+                if len(curHeader.actors.actorList) > 0:
+                    roomXML += curHeader.actors.getXML()
+
+                roomXML += f"<!-- Header {i}: \"{headerDesc}\" end -->\n"
+
+        return roomXML
+
     def getRoomShapeModelC(self, textureSettings: TextureExportSettings):
         """Returns the C data of the room model"""
         roomModel = CData()
@@ -239,41 +281,43 @@ class Room:
         logging_func({"INFO"}, "getRoomModelXML 0")
 
         for i, entry in enumerate(self.roomShape.dl_entries):
-            if entry.DLGroup.opaque is not None:
-                logging_func({"INFO"}, "getRoomModelXML 1")
-                roomModel += "<!-- getRoomModelXML entry.DLGroup.opaque start "
-                roomModel += entry.DLGroup.opaque.to_soh_xml(resourceBasePath[:-1], resourceBasePath[:-1])
-                roomModel += " getRoomModelXML entry.DLGroup.opaque end -->"
+            if entry.opaque is not None:
+                logging_func({"INFO"}, f"getRoomModelXML 1")
+                roomModel += "<!-- getRoomModelXML entry.opaque start "
+                roomModel += entry.opaque.to_xml(resourceBasePath[:-1], resourceBasePath[:-1])
+                roomModel += " getRoomModelXML entry.opaque end -->"
 
-            if entry.DLGroup.transparent is not None:
+            if entry.transparent is not None:
                 logging_func({"INFO"}, "getRoomModelXML 2")
-                roomModel += "<!-- getRoomModelXML entry.DLGroup.transparent start "
-                roomModel += entry.DLGroup.transparent.to_soh_xml(resourceBasePath[:-1], resourceBasePath[:-1])
-                roomModel += " getRoomModelXML entry.DLGroup.transparent end -->"
+                roomModel += "<!-- getRoomModelXML entry.transparent start "
+                roomModel += entry.transparent.to_xml(resourceBasePath[:-1], resourceBasePath[:-1])
+                roomModel += " getRoomModelXML entry.transparent end -->"
+
+            logging_func({"INFO"}, f"getRoomModelXML 2.5 self.roomShape.roomShape={self.roomShape.roomShape}")
 
             # type ``ROOM_SHAPE_TYPE_IMAGE`` only allows 1 room
-            if i == 0 and self.roomShape.roomShape == "ROOM_SHAPE_TYPE_IMAGE":
+            if i == 0 and isinstance(self.roomShape, RoomShapeImageBase):
                 break
 
         logging_func(
             {"INFO"},
-            "getRoomModelXML 3 textureExportSettings.exportPath="
-            + (textureExportSettings.exportPath if textureExportSettings.exportPath is not None else "None"),
+            "getRoomModelXML 3 textureExportSettings.exportPath=" +
+            (textureExportSettings.exportPath if textureExportSettings.exportPath is not None else "None"),
         )
         logging_func(
-            {"INFO"}, "getRoomModelXML 4 resourceBasePath=" + (resourceBasePath if resourceBasePath is not None else "None")
+            {"INFO"}, "getRoomModelXML 4 resourceBasePath=" +
+            (resourceBasePath if resourceBasePath is not None else "None")
         )
-        roomModel += "<!-- getRoomModelXML self.roomShape.to_soh_xml start -->"
-        roomModel += self.roomShape.model.to_soh_xml(
+        roomModel += "<!-- getRoomModelXML self.roomShape.to_xml start -->"
+        roomModel += self.roomShape.model.to_xml(
             os.path.join(textureExportSettings.exportPath, ""), resourceBasePath[:-1], logging_func
         )
-        roomModel += "<!-- getRoomModelXML self.roomShape.to_soh_xml end -->"
+        roomModel += "<!-- getRoomModelXML self.roomShape.to_xml end -->"
 
-        logging_func({"INFO"}, "getRoomModelXML 5")
-        roomModel += "<!-- getRoomModelXML getRoomShapeImageData start -->"
-        roomModel += str(getRoomShapeImageData(self.roomShape, textureExportSettings))
-        roomModel += "<!-- getRoomModelXML getRoomShapeImageData end -->"
-        logging_func({"INFO"}, "getRoomModelXML 6")
+
+        if isinstance(self.roomShape, RoomShapeImageMulti):
+            # roomModel.append(self.roomShape.multiImg.getC()) # Error? double call in getRoomShapeC()?
+            roomModel += f"<!-- self.roomShape.to_c_img(textureSettings.includeDir)={self.roomShape.to_c_img(textureSettings.includeDir)} -->"
 
     def getNewRoomFile(self, path: str, isSingleFile: bool, textureExportSettings: TextureExportSettings):
         """Returns a new ``RoomFile`` element"""
diff --git a/fast64_internal/oot/exporter/room/header.py b/fast64_internal/oot/exporter/room/header.py
index d35d4fa..ea255ac 100644
--- a/fast64_internal/oot/exporter/room/header.py
+++ b/fast64_internal/oot/exporter/room/header.py
@@ -129,17 +129,8 @@ class RoomObjects:
     def getCmdXML(self):
         """Returns the object list room command"""
 
-        data = indent + f"<SetObjectList>\n"
-        for entry in self.objectList:
-            objectID = entry
-            for i, objectElement in enumerate(ootObjectIds):
-                if objectElement == objectID:
-                    objectID = i
-
-            data += indent * 2 + f'<ObjectEntry Id="{objectID}"/>\n'
-        data += indent + f"</SetObjectList>\n"
-
-        return data
+        # The data is inline
+        return self.getXML()
 
     def getC(self):
         """Returns the array with the objects the room uses"""
@@ -245,7 +236,7 @@ class RoomActors:
         """Returns the actor list room command"""
 
         # the data is inline
-        return getXML()
+        return self.getXML()
 
     def getC(self):
         """Returns the array with the actors the room uses"""
diff --git a/fast64_internal/oot/exporter/scene/__init__.py b/fast64_internal/oot/exporter/scene/__init__.py
index f8b83cd..c3fc64e 100644
--- a/fast64_internal/oot/exporter/scene/__init__.py
+++ b/fast64_internal/oot/exporter/scene/__init__.py
@@ -125,6 +125,28 @@ class Scene:
 
         return cmdListData
 
+    def getCmdListXML(self, curHeader: SceneHeader, hasAltHeaders: bool):
+        """Returns the scene's commands list"""
+
+        cmdListData = (
+            "{"
+            + "<!--" + (Utility.getAltHeaderListCmd(self.altHeader.name) if hasAltHeaders else "") + "-->"
+            + self.colHeader.getCmdXML()
+            + self.rooms.getCmdXML()
+            + curHeader.infos.getCmdsXML(curHeader.lighting)
+            + curHeader.lighting.getCmdXML()
+            + curHeader.path.getCmdXML()
+            + (curHeader.transitionActors.getCmdXML() if len(curHeader.transitionActors.entries) > 0 else "")
+            + curHeader.spawns.getCmdXML()
+            + curHeader.entranceActors.getCmdXML()
+            + (curHeader.exits.getCmdXML() if len(curHeader.exits.exitList) > 0 else "")
+            + "<!-- TODO: Cutscenes -->"
+            + Utility.getEndCmdXML()
+            + "}"
+        )
+
+        return cmdListData
+
     def getSceneMainC(self):
         """Returns the main informations of the scene as ``CData``"""
 
@@ -166,6 +188,42 @@ class Scene:
 
         return sceneC
 
+    def getSceneMainXML(self):
+        """Returns the main informations of the scene as ``CData``"""
+
+        sceneXML = ""
+        headers: list[tuple[SceneHeader, str]] = []
+        altHeaderPtrs = None
+
+        if self.hasAlternateHeaders:
+            headers = [
+                (self.altHeader.childNight, "Child Night"),
+                (self.altHeader.adultDay, "Adult Day"),
+                (self.altHeader.adultNight, "Adult Night"),
+            ]
+
+            for i, csHeader in enumerate(self.altHeader.cutscenes):
+                headers.append((csHeader, f"Cutscene No. {i + 1}"))
+
+            altHeaderPtrs = "\n".join(
+                indent + curHeader.name + "," if curHeader is not None else indent + "NULL," if i < 4 else ""
+                for i, (curHeader, _) in enumerate(headers, 1)
+            )
+
+        headers.insert(0, (self.mainHeader, "Child Day (Default)"))
+        for i, (curHeader, headerDesc) in enumerate(headers):
+            if curHeader is not None:
+                sceneXML += "<!--\n - " + f"Header {headerDesc}\n" + "-->\n"
+                sceneXML += self.getCmdListXML(curHeader, i == 0 and self.hasAlternateHeaders)
+
+                if i == 0:
+                    if self.hasAlternateHeaders and altHeaderPtrs is not None:
+                        sceneXML += f"<!--self.altHeader.name={self.altHeader.name} altHeaderPtrs={altHeaderPtrs}-->"
+
+                sceneXML += curHeader.getXML()
+
+        return sceneXML
+
     def getSceneCutscenesC(self):
         """Returns the cutscene informations of the scene as ``CData``"""
 
diff --git a/fast64_internal/oot/exporter/scene/actors.py b/fast64_internal/oot/exporter/scene/actors.py
index 8f7735b..cd3d513 100644
--- a/fast64_internal/oot/exporter/scene/actors.py
+++ b/fast64_internal/oot/exporter/scene/actors.py
@@ -36,6 +36,25 @@ class TransitionActor(Actor):
             + ("\n" + indent + "},\n")
         )
 
+    def getEntryXML(self):
+        """Returns a single transition actor entry"""
+
+        #temporary to convert from actor enum to int
+        actorID = self.id
+        for i, actorElement in enumerate(ootActorIds):
+            if actorElement == actorID:
+                actorID = i
+
+        return (
+            indent * 2
+            + f'<TransitionActorEntry FrontSideRoom="{self.roomFrom}" FrontSideEffects="{self.cameraFront}"'
+            + f' BackSideRoom="{self.roomTo}" BackSideEffects="{self.cameraBack}"'
+            + f' Id="{actorID}"'
+            + f' PosX="{self.pos[0]}" PosY="{self.pos[1]}" PosZ="{self.pos[2]}"'
+            + f' RotY="{self.rot}" Params="{int(self.params, 16)}"/>'
+            + f' <!-- name={self.name if self.name != "" else "[None]"} -->\n'
+        )
+
 
 @dataclass
 class SceneTransitionActors:
@@ -102,6 +121,12 @@ class SceneTransitionActors:
 
         return indent + f"SCENE_CMD_TRANSITION_ACTOR_LIST({len(self.entries)}, {self.name}),\n"
 
+    def getCmdXML(self):
+        """Returns the transition actor list scene command"""
+
+        #the data is inline
+        return self.getXML()
+
     def getC(self):
         """Returns the transition actor array"""
 
@@ -118,6 +143,19 @@ class SceneTransitionActors:
 
         return transActorList
 
+    def getXML(self):
+        """Returns the transition actor array"""
+
+        transActorList = ""
+        listName = f"TransitionActorEntry {self.name}"
+
+        return (
+            indent +
+            "<SetTransitionActorList>\n" +
+            "\n".join(transActor.getEntryXML() for transActor in self.entries) + "\n" +
+            "</SetTransitionActorList>\n"
+        )
+
 
 @dataclass
 class EntranceActor(Actor):
@@ -131,6 +169,14 @@ class EntranceActor(Actor):
 
         return indent + "{ " + f"{self.spawnIndex}, {self.roomIndex}" + " },\n"
 
+    def getEntryXML(self):
+        """Returns a single spawn entry"""
+
+        return (
+            indent * 2 +
+            f'<EntranceEntry Spawn="{self.spawnIndex}" Room="{self.roomIndex}"/>\n'
+        )
+
 
 @dataclass
 class SceneEntranceActors:
@@ -187,6 +233,12 @@ class SceneEntranceActors:
         name = self.name if len(self.entries) > 0 else "NULL"
         return indent + f"SCENE_CMD_SPAWN_LIST({len(self.entries)}, {name}),\n"
 
+    def getCmdXML(self):
+        """Returns the spawn list scene command"""
+
+        #the data is inline
+        return self.getXML()
+
     def getC(self):
         """Returns the spawn actor array"""
 
@@ -203,6 +255,15 @@ class SceneEntranceActors:
 
         return spawnActorList
 
+    def getXML(self):
+        """Returns the spawn actor array"""
+
+        return (
+            indent + "<SetEntranceList>\n" +
+            "".join(entrance.getActorEntry() for entrance in self.entries) +
+            indent + "</SetEntranceList>"
+        )
+
 
 @dataclass
 class SceneSpawns(Utility):
@@ -216,6 +277,12 @@ class SceneSpawns(Utility):
 
         return indent + f"SCENE_CMD_ENTRANCE_LIST({self.name if len(self.entries) > 0 else 'NULL'}),\n"
 
+    def getCmdXML(self):
+        """Returns the entrance list scene command"""
+
+        #the data is inline
+        return self.getXML()
+
     def getC(self):
         """Returns the spawn array"""
 
@@ -234,3 +301,12 @@ class SceneSpawns(Utility):
         )
 
         return spawnList
+
+    def getXML(self):
+        """Returns the spawn array"""
+
+        return (
+            indent + "<SetEntranceList>\n" +
+            "".join(entrance.getEntryXML() for entrance in self.entries) +
+            indent + "</SetEntranceList>"
+        )
diff --git a/fast64_internal/oot/exporter/scene/general.py b/fast64_internal/oot/exporter/scene/general.py
index 2a1638d..8cd8c02 100644
--- a/fast64_internal/oot/exporter/scene/general.py
+++ b/fast64_internal/oot/exporter/scene/general.py
@@ -25,6 +25,11 @@ class EnvLightSettings:
 
         return f"(({self.blendRate} << 10) | {self.fogNear})"
 
+    def getBlendFogNearXML(self):
+        """Returns the packed blend rate and fog near values"""
+
+        return ((self.blendRate << 10) | self.fogNear)
+
     def getColorValues(self, vector: tuple[int, int, int]):
         """Returns and formats color values"""
 
@@ -79,6 +84,44 @@ class EnvLightSettings:
 
         return lightData
 
+    def getEntryXML(self, index: int):
+        """Returns an environment light entry"""
+
+        isLightingCustom = self.envLightMode == "Custom"
+
+        lightDescs = ["Dawn", "Day", "Dusk", "Night"]
+
+        if not isLightingCustom and self.envLightMode == "LIGHT_MODE_TIME":
+            # TODO: Improve the lighting system.
+            # Currently Fast64 assumes there's only 4 possible settings for "Time of Day" lighting.
+            # This is not accurate and more complicated,
+            # for now we are doing ``index % 4`` to avoid having an OoB read in the list
+            # but this will need to be changed the day the lighting system is updated.
+            lightDesc = f"<!-- {lightDescs[index % 4]} Lighting -->\n"
+        else:
+            isIndoor = not isLightingCustom and self.envLightMode == "LIGHT_MODE_SETTINGS"
+            lightDesc = f"<!-- {'Indoor' if isIndoor else 'Custom'} No. {index + 1} Lighting -->\n"
+
+        return (
+            f"<LightingSetting"
+            + f' AmbientColorR="{self.ambientColor[0]}" AmbientColorG="{self.ambientColor[1]}" AmbientColorB="{self.ambientColor[2]}"'
+
+            + f' Light1DirX="{str(self.light1Dir[0] - 0x100 if self.light1Dir[0] > 0x7F else f"{self.light1Dir[0]:5}").strip()}"'
+            + f' Light1DirY="{str(self.light1Dir[1] - 0x100 if self.light1Dir[1] > 0x7F else f"{self.light1Dir[1]:5}").strip()}"'
+            + f' Light1DirZ="{str(self.light1Dir[2] - 0x100 if self.light1Dir[2] > 0x7F else f"{self.light1Dir[2]:5}").strip()}"'
+            + f' Light1ColorR="{self.light1Color[0]}" Light1ColorG="{self.light1Color[1]}" Light1ColorB="{self.light1Color[2]}"'
+
+            + f' Light2DirX="{str(self.light2Dir[0] - 0x100 if self.light2Dir[0] > 0x7F else f"{self.light2Dir[0]:5}").strip()}"'
+            + f' Light2DirY="{str(self.light2Dir[1] - 0x100 if self.light2Dir[1] > 0x7F else f"{self.light2Dir[1]:5}").strip()}"'
+            + f' Light2DirZ="{str(self.light2Dir[2] - 0x100 if self.light2Dir[2] > 0x7F else f"{self.light2Dir[2]:5}").strip()}"'
+            + f' Light2ColorR="{self.light2Color[0]}" Light2ColorG="{self.light2Color[1]}" Light2ColorB="{self.light2Color[2]}"'
+
+            + f' FogColorR="{self.fogColor[0]}" FogColorG="{self.fogColor[1]}" FogColorB="{self.fogColor[2]}"'
+            + f' FogNear="{self.getBlendFogNearXML()}" FogFar="{self.zFar}"'
+            + f"/>"
+            + lightDesc
+        )
+
 
 @dataclass
 class SceneLighting:
@@ -126,6 +169,12 @@ class SceneLighting:
             indent + "SCENE_CMD_ENV_LIGHT_SETTINGS("
         ) + f"{len(self.settings)}, {self.name if len(self.settings) > 0 else 'NULL'}),\n"
 
+    def getCmdXML(self):
+        """Returns the env light settings scene command"""
+
+        #the data is inline
+        return self.getXML()
+
     def getC(self):
         """Returns a ``CData`` containing the C data of env. light settings"""
 
@@ -142,6 +191,15 @@ class SceneLighting:
 
         return lightSettingsC
 
+    def getXML(self):
+        """Returns a string containing the XML data of env. light settings"""
+
+        return (
+            indent + "<SetLightingSettings>\n" +
+            "".join(light.getEntryXML(i) for i, light in enumerate(self.settings)) +
+            indent + "</SetLightingSettings>"
+        )
+
 
 @dataclass
 class SceneInfos:
@@ -208,6 +266,22 @@ class SceneInfos:
         )
 
 
+    def getCmdsXML(self, lights: SceneLighting):
+        """Returns the sound settings, misc settings, special files and skybox settings scene commands"""
+
+        return (
+            f"\n{indent}".join(
+                [
+                    f'<SetSoundSettings Reverb="{self.specID}" NatureAmbienceId="{int(self.ambienceID, 16)}" SeqId="{self.sequenceID}"/>',
+                    f'<SetCameraSettings CameraMovement="{int(self.sceneCamType, 16)}" WorldMapArea="{int(self.worldMapLocation, 16)}"/>',
+                    f'<SetSpecialObjects ElfMessage="{self.naviHintType}" GlobalObject="{self.keepObjectID}"/>',
+                    f'<SetSkyboxSettings Unknown="0" SkyboxId="{int(self.skyboxID, 16)}" Weather="{int(self.skyboxConfig, 16)}" Indoors="{int(lights.envLightMode == "true")}"/>',
+                ]
+            )
+            + "\n"
+        )
+
+
 @dataclass
 class SceneExits(Utility):
     """This class hosts exit data"""
@@ -231,6 +305,12 @@ class SceneExits(Utility):
 
         return indent + f"SCENE_CMD_EXIT_LIST({self.name}),\n"
 
+    def getCmdXML(self):
+        """Returns the exit list scene command"""
+
+        #the data is inline
+        return self.getXML()
+
     def getC(self):
         """Returns a ``CData`` containing the C data of the exit array"""
 
@@ -249,3 +329,24 @@ class SceneExits(Utility):
         )
 
         return exitListC
+
+    def getXML(self):
+        """Returns a ``CData`` containing the C data of the exit array"""
+
+        #return (
+        #    indent + "<SetExitList>\n" +
+        #    "\n".join(indent * 2 + f"<ExitEntry Id="{value}"/>" for (_, value) in self.exitList) +
+        #    indent + "</SetExitList>"
+        #)
+
+        data = indent + "<SetExitList>\n"
+        for _, value in self.exitList:
+            entranceID = value.index
+            for i, entranceElement in enumerate(ootEntranceIds):
+                if entranceElement == entranceID:
+                    entranceID = i
+
+            data += indent * 2 + f'<ExitEntry Id="{entranceID}"/>\n'
+        data += indent + "</SetExitList>"
+
+        return data
diff --git a/fast64_internal/oot/exporter/scene/header.py b/fast64_internal/oot/exporter/scene/header.py
index 72bc8d3..806efdd 100644
--- a/fast64_internal/oot/exporter/scene/header.py
+++ b/fast64_internal/oot/exporter/scene/header.py
@@ -69,6 +69,34 @@ class SceneHeader:
 
         return headerData
 
+    def getXML(self):
+        """Returns the string containing the header's data"""
+
+        headerData = ""
+
+        # Write the spawn position list data and the entrance list
+        if len(self.entranceActors.entries) > 0:
+            headerData += self.entranceActors.getXML()
+            headerData += self.spawns.getXML()
+
+        # Write the transition actor list data
+        if len(self.transitionActors.entries) > 0:
+            headerData += self.transitionActors.getXML()
+
+        # Write the exit list
+        if len(self.exits.exitList) > 0:
+            headerData += self.exits.getXML()
+
+        # Write the light data
+        if len(self.lighting.settings) > 0:
+            headerData += self.lighting.getXML()
+
+        # Write the path data, if used
+        if len(self.path.pathList) > 0:
+            headerData += self.path.getXML()
+
+        return headerData
+
 
 @dataclass
 class SceneAlternateHeader:
diff --git a/fast64_internal/oot/exporter/scene/pathways.py b/fast64_internal/oot/exporter/scene/pathways.py
index 331af8d..f5ccbfc 100644
--- a/fast64_internal/oot/exporter/scene/pathways.py
+++ b/fast64_internal/oot/exporter/scene/pathways.py
@@ -34,6 +34,19 @@ class Path:
 
         return pathData
 
+    def getXML(self):
+        """Returns the pathway position array"""
+
+        return (
+            indent
+            + "<PathData>\n"
+            + "\n".join(
+                indent * 2 + f'<PathPoint X="{f"{round(point[0]):5}"}" Y="{f"{round(point[1]):5}"}" Z="{f"{round(point[2]):5}"}"/>' for point in self.points
+            )
+            + indent
+            + "</PathData>\n"
+        )
+
 
 @dataclass
 class ScenePathways:
@@ -71,6 +84,23 @@ class ScenePathways:
 
         return indent + f"SCENE_CMD_PATH_LIST({self.name}),\n" if len(self.pathList) > 0 else ""
 
+    def getCmdXML(self):
+        """Returns the path list scene command"""
+
+        return indent + f"SCENE_CMD_PATH_LIST({self.name}),\n" if len(self.pathList) > 0 else ""
+
+        if len(self.pathList) < 0:
+            return ""
+
+        data = indent + f"<SetPathways>\n"
+        for i in range(len(outScene.pathList)):
+            data += (
+                indent * 2 + f'<Pathway FilePath="{{resource_base_path}}/{self.name}_{str(i)}.xml"/>\n'
+            )
+        data += indent + f"</SetPathways>"
+
+        return data
+
     def getC(self):
         """Returns a ``CData`` containing the C data of the pathway array"""
 
@@ -92,3 +122,12 @@ class ScenePathways:
         pathData.append(pathListData)
 
         return pathData
+
+    def getXML(self):
+        """Returns a string containing the XML data of the pathway array"""
+
+        return (
+            "<Path>\n" +
+            (path.getXML() for path in self.pathList) +
+            "</Path>"
+        )
diff --git a/fast64_internal/oot/exporter/scene/rooms.py b/fast64_internal/oot/exporter/scene/rooms.py
index 6948ef6..5f8bc8a 100644
--- a/fast64_internal/oot/exporter/scene/rooms.py
+++ b/fast64_internal/oot/exporter/scene/rooms.py
@@ -59,6 +59,20 @@ class RoomEntries:
 
         return indent + f"SCENE_CMD_ROOM_LIST({len(self.entries)}, {self.name}),\n"
 
+    def getCmdXML(self):
+        """Returns the room list scene command"""
+
+        return (
+            indent +
+            "<SetRoomList>\n" +
+            (
+                indent * 2 + f'<RoomEntry Path="{{resource_base_path}}/{self.name}_room_{str(room)}.xml"/>\n'
+                for room in self.rooms.entries
+            ) +
+            indent +
+            "</SetRoomList>"
+        )
+
     def getC(self, useDummyRoomList: bool):
         """Returns the ``CData`` containing the room list array"""
 
diff --git a/fast64_internal/oot/exporter/utility.py b/fast64_internal/oot/exporter/utility.py
index 16a7659..2ac9a51 100644
--- a/fast64_internal/oot/exporter/utility.py
+++ b/fast64_internal/oot/exporter/utility.py
@@ -93,3 +93,9 @@ class Utility:
         """Returns the scene end command"""
 
         return indent + "SCENE_CMD_END(),\n"
+
+    @staticmethod
+    def getEndCmdXML():
+        """Returns the scene end command"""
+
+        return indent + "<EndMarker/>\n"
diff --git a/fast64_internal/oot/scene/operators.py b/fast64_internal/oot/scene/operators.py
index db7d41a..0d41cc6 100644
--- a/fast64_internal/oot/scene/operators.py
+++ b/fast64_internal/oot/scene/operators.py
@@ -157,7 +157,12 @@ class OOT_ExportScene(Operator):
             bootOptions = context.scene.fast64.oot.bootupSceneOptions
             hackerFeaturesEnabled = (context.scene.fast64.oot.featureSet == "HackerOOT")
 
-            if settings.customExport:
+            if context.scene.fast64.oot.featureSet == "SoH":
+                levelName = sceneNameFromID(option)
+                isCustomExport = True
+                exportPath = bpy.path.abspath(settings.exportPath)
+                customSubPath = None
+            elif settings.customExport:
                 isCustomExport = True
                 exportPath = bpy.path.abspath(settings.exportPath)
                 customSubPath = None
@@ -182,11 +187,19 @@ class OOT_ExportScene(Operator):
                 bootOptions if hackerFeaturesEnabled else None,
             )
 
-            SceneExport.export(
-                obj,
-                finalTransform,
-                exportInfo,
-            )
+            if context.scene.fast64.oot.featureSet == "SoH":
+                SceneExport.export_xml(
+                    obj,
+                    finalTransform,
+                    exportInfo,
+                    self.report
+                )
+            else:
+                SceneExport.export(
+                    obj,
+                    finalTransform,
+                    exportInfo,
+                )
 
             self.report({"INFO"}, "Success!")
 
diff --git a/fast64_internal/oot/scene/panels.py b/fast64_internal/oot/scene/panels.py
index b5beb90..d324091 100644
--- a/fast64_internal/oot/scene/panels.py
+++ b/fast64_internal/oot/scene/panels.py
@@ -39,7 +39,7 @@ class OOT_ExportScenePanel(OOT_Panel):
         exportBox.label(text="Scene Exporter")
 
         settings: OOTExportSceneSettingsProperty = context.scene.ootSceneExportSettings
-        if not settings.customExport:
+        if not settings.customExport or context.scene.fast64.oot.featureSet == "SoH":
             self.drawSceneSearchOp(exportBox, settings.option, "Export")
         settings.draw_props(exportBox)
 
@@ -69,6 +69,9 @@ class OOT_ExportScenePanel(OOT_Panel):
         importSettings.draw_props(importBox, importSettings.option)
         importBox.operator(OOT_ImportScene.bl_idname)
 
+        if context.scene.fast64.oot.featureSet == "SoH":
+            return
+
         # Remove Scene
         removeBox = col.box().column()
         removeBox.label(text="Remove Scene")
diff --git a/fast64_internal/oot/scene/properties.py b/fast64_internal/oot/scene/properties.py
index b48948e..72d7b4a 100644
--- a/fast64_internal/oot/scene/properties.py
+++ b/fast64_internal/oot/scene/properties.py
@@ -477,6 +477,13 @@ class OOTRemoveSceneSettingsProperty(PropertyGroup):
             prop_split(layout, self, "name", "Name")
 
 
+sohResourcePathEnum = (
+    ("Shared", "Shared", "Scenes in both Vanilla & MQ"),
+    ("Vanilla", "Vanilla", "Vanilla Dungeons"),
+    ("MQ", "MQ", "MQ Dungeons"),
+)
+
+
 class OOTExportSceneSettingsProperty(PropertyGroup):
     name: StringProperty(name="Name", default="spot03")
     subFolder: StringProperty(name="Subfolder", default="overworld")
@@ -489,10 +496,25 @@ class OOTExportSceneSettingsProperty(PropertyGroup):
     )
     option: EnumProperty(items=ootEnumSceneID, default="SCENE_DEKU_TREE")
 
+    sohResourcePath: EnumProperty(items=sohResourcePathEnum, default="Shared")
+    sohCustomResourcePath: StringProperty(name="Custom Resource Path")
+
     # keeping this on purpose, will be removed once old code is cleaned-up
     useNewExporter: BoolProperty(name="Use New Exporter", default=True)
 
     def draw_props(self, layout: UILayout):
+        if bpy.context.scene.fast64.oot.featureSet == "SoH":
+            prop_split(layout, self, "exportPath", "Directory")
+
+            if self.option == "Custom":
+                prop_split(layout, self, "name", "Name")
+                prop_split(layout, self, "sohCustomResourcePath", "Custom Resource Path")
+            else:
+                prop_split(layout, self, "sohResourcePath", "Resource Path")
+
+            prop_split(layout, bpy.context.scene, "ootSceneExportObj", "Scene Object")
+            return
+
         if self.customExport:
             prop_split(layout, self, "exportPath", "Directory")
             prop_split(layout, self, "name", "Name")
